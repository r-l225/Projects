#include <DFRobot_BMI160.h> 

// Gyroscope Variables
DFRobot_BMI160 bmi160;
const int8_t i2c_addr = 0x69;
float angle = 0;  // Store accumulated yaw angle

// IR Sensor Pins 
int IRSensor1 = 36;
int IRSensor2 = 39;
int IRSensor3 = 34;
int IRSensor4 = 35;

const int trigPin = 26; 
const int echoPin = 25; 

//Motor Contorl Pins
const int L_PWM = 0; // PWM control for left motor
const int L_IN1 = 15; // Direction control for left motor
const int L_IN2 = 2; // Direction control for left motor
const int R_PWM = 4; // PWM control for right motor
const int R_IN1 = 16; // Direction control for right motor
const int R_IN2 = 17; // Direction control for right motor


// Thresholds
const int detectionThreshold = 60;

// State Machine
enum State { SEARCHING, MOVING_FORWARD, AVOID, STOPPED };
volatile State currentState = SEARCHING;

volatile uint8_t boundaryCode = 0xF;
volatile bool opponentDetected = false;

// Task handles
TaskHandle_t Task1;  // Sensor reading task
TaskHandle_t Task2;  // Motor control task

void IR_Sensor_setup();
uint8_t IR_Sensor_read();
void ultra_Sensor_setup();
float ultra_Sensor_read();
void TaskSensors(void *pvParameters);
void TaskNavigation(void *pvParameters);
void forwardMotors();
void rotateMotors();
void stopMotors();
void reverseMotors();
void turnLeft();
void turnRight();
void changeState();
void readGyroData();

void setup() {
  Serial.begin(115200);

  IR_Sensor_setup();
  ultra_Sensor_setup();

  // Initialize the BMI160 gyroscope
  if (bmi160.softReset() != BMI160_OK) {
    Serial.println("Gyroscope reset failed.");
    while (1);
  }
  if (bmi160.I2cInit(i2c_addr) != BMI160_OK) {
    Serial.println("Gyroscope initialization failed.");
    while (1);
  }

  // Motor pin setup
  pinMode(L_PWM, OUTPUT);
  pinMode(L_IN1, OUTPUT);
  pinMode(L_IN2, OUTPUT);
  pinMode(R_PWM, OUTPUT);
  pinMode(R_IN1, OUTPUT);
  pinMode(R_IN2, OUTPUT);

  // Create the sensor and navigation tasks
  xTaskCreatePinnedToCore(TaskSensors, "TaskSensors", 10000, NULL, 1, &Task1, 1);  // Core 1 for sensors and state management
  xTaskCreatePinnedToCore(TaskNavigation, "TaskNavigation", 10000, NULL, 2, &Task2, 0);  // Core 0 for motor control
}

void loop() {
}

// Core 1: Sensor data collection and state management
void TaskSensors(void *pvParameters) {
  for (;;) {
    boundaryCode = IR_Sensor_read();
    float distance = ultra_Sensor_read();
    opponentDetected = (distance < detectionThreshold);
    changeState();
    vTaskDelay(100 / portTICK_PERIOD_MS);
  }
}

// Handle state changes based on sensor input
void changeState() {
  if (boundaryCode != 0xF) {
    currentState = AVOID;
    Serial.println("State changed to avoid.");
  } else if (opponentDetected) {
    currentState = MOVING_FORWARD;
    Serial.println("State changed to move forward.");
  } else {
    currentState = SEARCHING;
    Serial.println("State cahnged to searching.");
  }
}

// Core 0: Navigation and motor control
void TaskNavigation(void *pvParameters) {
  for (;;) {
    switch (currentState) {
      case SEARCHING:
      Serial.println("Searshing.");
        rotateMotors();
        break;
      case MOVING_FORWARD:
      Serial.println("Moving Forward.");
        moveForward(); 
        break;
      case AVOID:
      Serial.println("Avoid.");
       handleBoundaryMovement();
        break;
      case STOPPED:
      Serial.println("Stopped.");
        stopMotors();
        break;
    }
    vTaskDelay(100/ portTICK_PERIOD_MS);
  }
}

// Read gyroscope data and update the yaw angle
void readGyroData() {
  int16_t accelGyro[6] = {0};
  if (bmi160.getAccelGyroData(accelGyro) == 0) {
    float yaw = (accelGyro[2] * 3.14 / 180.0 + 0.18) * 9 / 7;
    if (yaw > 0.25) {
      angle += yaw / 3.14;
    } else if (yaw <= 0.25 && yaw >= -0.25) {
      angle += 0;
    } else {
      angle -= abs(yaw / 3.14);
    }
  }
}

// Forward movement with gyroscope correction

void handleBoundaryMovement() {
  switch (boundaryCode) {
    case 0x7:
      moveForward();
      Serial.println("7.");
      break;
    case 0xB:
      moveForward();
      Serial.println("B");
      break;
    case 0xD:
     reversePivot();
      Serial.println("D");
      break;
      case 0xE:
      reversePivot();
      Serial.println("E");
      break;
    case 0x3:
      moveForward();
      Serial.println("3");
      break;
    case 0xC:
      reversePivot();
      Serial.println("C");
      break;
    case 0x5:
      sharpLeft();
      Serial.println("5");
      break;
    case 0xA:
      sharpRight();
      Serial.println("A");
      break;
    default:
      stopMotors();
      Serial.println("Rotating DEFAULT.");
      break;
  }
}

void IR_Sensor_setup() {
  pinMode(IRSensor1, INPUT);
  pinMode(IRSensor2, INPUT);
  pinMode(IRSensor3, INPUT);
  pinMode(IRSensor4, INPUT);
}

uint8_t IR_Sensor_read() {
  int status1 = digitalRead(IRSensor1);
  int status2 = digitalRead(IRSensor2);
  int status3 = digitalRead(IRSensor3);
  int status4 = digitalRead(IRSensor4);

  uint8_t boundaryCode = (status4 << 3) | (status3 << 2) | (status2 << 1) | status1;
  
  Serial.print("Sensor States: ");
  Serial.print("Front-Left: "); Serial.print(status1);
  Serial.print(" | Front-Right: "); Serial.print(status2);
  Serial.print(" | Back-Left: "); Serial.print(status3);
  Serial.print(" | Back-Right: "); Serial.println(status4);
  Serial.print("Boundary Code: ");
  Serial.println(boundaryCode, BIN);

  return boundaryCode;
}




void ultra_Sensor_setup() {
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
}

float ultra_Sensor_read() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH);
  return (duration * 0.034) / 2;
}

void moveForward() {
  Serial.println("Moving Forward.");
  digitalWrite(L_IN1, HIGH);
  digitalWrite(L_IN2, LOW);
  analogWrite(L_PWM, 255);  // Full speed forward for left motor

  digitalWrite(R_IN1, HIGH);
  digitalWrite(R_IN2, LOW);
  analogWrite(R_PWM, 255);  // Full speed forward for right motor
  
}

void rotateMotors() {
  digitalWrite(L_IN1, HIGH);
  digitalWrite(L_IN2, LOW);
  analogWrite(L_PWM, 150);  // Medium speed forward for left motor

  digitalWrite(R_IN1, LOW);
  digitalWrite(R_IN2, HIGH);
  analogWrite(R_PWM, 150);
  delay(1000); 
}

void curveRight() {
  Serial.println("Curving Right.");
  digitalWrite(L_IN1, HIGH);
  digitalWrite(L_IN2, LOW);
  analogWrite(L_PWM, 150);  // Reduce left motor speed for gentle right curve

  digitalWrite(R_IN1, HIGH);
  digitalWrite(R_IN2, LOW);
  analogWrite(R_PWM, 255);  // Right motor at full speed
  delay(500); 
}

void curveLeft() {
  Serial.println("Curving Left.");
  digitalWrite(L_IN1, HIGH);
  digitalWrite(L_IN2, LOW);
  analogWrite(L_PWM, 255);  // Left motor at full speed

  digitalWrite(R_IN1, HIGH);
  digitalWrite(R_IN2, LOW);
  analogWrite(R_PWM, 150);  // Reduce right motor speed for gentle left curve
  delay(500); 
}

void sharpRight() {
  Serial.println("Sharp Right Turn.");
  digitalWrite(L_IN1, HIGH);
  digitalWrite(L_IN2, LOW);
  analogWrite(L_PWM, 255);  // Left motor at full speed

  digitalWrite(R_IN1, LOW);
  digitalWrite(R_IN2, LOW);
  analogWrite(R_PWM, 0);    // Right motor stopped for sharp turn
  delay(500); 
}

void sharpLeft() {
  Serial.println("Sharp Left Turn.");
  digitalWrite(L_IN1, LOW);
  digitalWrite(L_IN2, LOW);
  analogWrite(L_PWM, 0);    // Left motor stopped for sharp turn

  digitalWrite(R_IN1, HIGH);
  digitalWrite(R_IN2, LOW);
  analogWrite(R_PWM, 255);  // Right motor at full speed
  delay(500); 
}

void reversePivot() {
  Serial.println("Reversing and Pivoting.");
  
  // Reverse both motors briefly
  digitalWrite(L_IN1, LOW);
  digitalWrite(L_IN2, HIGH);
  analogWrite(L_PWM, 200);  // Reverse left motor at medium speed

  digitalWrite(R_IN1, LOW);
  digitalWrite(R_IN2, HIGH);
  analogWrite(R_PWM, 200);  // Reverse right motor at medium speed
  delay(500);               // Reverse for 500 ms

}

void stopMotors() {
  analogWrite(L_PWM, 0);
  analogWrite(R_PWM, 0);
}

void reverseMotors() {
  digitalWrite(L_IN1, LOW);
  digitalWrite(L_IN2, HIGH);
  analogWrite(L_PWM, 255);
  digitalWrite(R_IN1, LOW);
  digitalWrite(R_IN2, HIGH);
  analogWrite(R_PWM, 255);
   delay(300);
}
